"""
Name:       AppBot Class
Details:    This app bot class gives out the artificial intelligence
            of a certain simple instructions, this class contains
            automated input methods such as mouse inputs and keyboard inputs
            this also depends on the user's setup instructions
Author:     Raphael Di Ezmo
"""

import cv2 as cv
import pyautogui
from time import sleep, time
from threading import Thread, Lock

# enumerates the app bot status
class AppBotStatus:
    INITIALISING    = 0
    DETECTING       = 0
    PROCESSING      = 0

class AppBot:

    # AppBot Properties
    status              = None  # Holds the bot current status
    target_positions    = []    # this will contain the positions of the matched targets(x,y)
    instructions        = []    # this variable will contain the set of instructions

    # Window capture properties position
    wincap              = None  # The window capture class
    window_offset       = (0,0) # The window capture's offset
    window_w            = 0     # the window capture's width
    window_h            = 0     # the window capture's height

    # Threading Properties
    stop            = False
    lock            = None

    # Constructor, this construct the class AppBot object that contains the window's
    # offset of the targeted window and as well as it's window size
    def __init__(self, window_offset, window_size):

        # Initialising the Thread lock object
        self.lock = Lock()
        # For checking window position in the screen position, it'll be easier
        # to just get the offsets and the actual window size from the Window
        # Capture
        self.window_offset  = window_offset     # Initializing the window's offsets
        self.window_w       = window_size[0]    # Initializing the window's width
        self.window_h       = window_size[1]    # Initializing the window's height

        # Initialising status of the appBot
        self.status = AppBotStatus.INITIALISING

    # Getting all the possible target positions (x,y)
    def get_target_positions(self, target_positions):
        self.target_positions = target_positions


    # This method reads the following instructions -> the file must exist
    # if instructions.txt  doesn't exist, this will return error and program
    # must restart
    def read_instructions(self):
        # reading the text file
        file = open("instructions.txt","r")
        # reading the file line by line
        for line in file:
            stripped = line.strip().split()
            # appending the stripped line by line values
            self.instructions.append(stripped)


    # What this method does is, there will be a instruction that is generated by the user
    # this instruction will exist in the file that the javaFX is going to create -> instruction.txt
    # this method will read the instruction and will process the instruction step by step
    # since MMORPG has different type of deleting or removing items from the inventory
    # this also contains all the x,y axis of the detected object
    def process_the_instruction(self, x, y):

        # For Debugging purposes
        print("moving to the {} {}".format(x, y))
        print(pyautogui.position())

        # Mouse pointer moves to the given x and y axis
        pyautogui.moveTo(x, y)
        # Clicking the targeted position using right click button
        pyautogui.mouseDown(button='right')
        pyautogui.mouseUp(button='right')

    # translate a pixel position on a screenshot image to a pixel position on the screen.
    # position = (x, y)
    # WARNING: if you move the window being captured after execution is started, this will
    # return incorrect coordinates, because the window position is only calculated in
    # the __init__ constructor.
    def get_screen_position(self, position):
        return (position[0] + self.offset_x, position[1] + self.offset_y)

    # This updates the position of the mouse
    def update_position(self, x, y):
        self.x_target = x
        self.y_target = y

    # # -----------------------------------------------------------------
    # # -------------------- THREADING METHODS --------------------------
    # # -----------------------------------------------------------------

    # The method that will start the threading
    def start(self):
        self.stopped = False
        t = Thread(target=self.run)
        t.start()

    # Method that will stop the function of the thread
    def stop(self):
        self.stopped = True

    # Method that runs all the functionality of the AppBot
    def run(self):

        # first is to initiate the target positions
        while not self.stopped:

            # If the status of the class is currently INITIALISING state
            if self.status == AppBotStatus.INITIALISING:
                # Locking the current state of the thread
                self.lock.acquire()
                # Bot will update the status to detecting
                self.status = AppBotStatus.DETECTING
                # Once the status of the application bot is updated then lock will release
                self.lock.release()

            # If the status of the class is currently in DETECTING state
            elif self.status == AppBotStatus.DETECTING:
                # Locking the current status of the thread
                self.lock.acquire()
                # Bot will update the status to processing
                self.status = AppBotStatus.PROCESSING
                # Once the status of the application bot is updated then lock will release
                self.lock.release()

            # If the status of the class is currently in PROCESSING state
            elif self.status == AppBotStatus.PROCESSING:
                # This locks the current status of the bot
                self.lock.acquire()
                # Bot will reset the app bot status to initialising again
                self.status = AppBotStatus.INITIALISING
                # Once the status of the application is reset then lock will release
                self.lock.release()


#   Click the water bundle
#   if Detected object == 1 -> Get position -> Click
#   Click the brown scroll
#   Click the water bundle
#   if Detected object == 2 -> Get position -> if position(x,y) doesnt exist -> Click
#   Click the brown scroll
#   Click the water bundle
#   if Detected object == 3 -> Get position -> if position(x,y) doesn't exist -> Click
#   ... until Detected object == 10
#   If Detected object == 10
#   rightclick the last (x,y) -> detect if the targeted (x,y) -> rightclick (x,y)